<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ZYB | NJUACMICPC</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></nav><div class="container post-meta"><div class="post-time">2017-10-14</div></div></div><div class="container post-header"><h1>ZYB</h1></div><div class="container post-content"><div class="figure">
<img src="/images/a.png">

</div>
<hr>
<p>给你两个长度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(01\)</span> 串 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> ，你可以做 <span class="math inline">\(3\)</span> 种操作：</p>
<ul>
<li>1：将 <span class="math inline">\(A\)</span> 串每一位向左移(即假设 <span class="math inline">\(A\)</span> 串 <span class="math inline">\(=A_1A_2…A_n\)</span>,将 <span class="math inline">\(A\)</span> 变为 <span class="math inline">\(A_2A_3…A_nA_1\)</span>)</li>
<li>2：将 <span class="math inline">\(A\)</span> 串每一位向右移(即假设 <span class="math inline">\(A\)</span> 串=<span class="math inline">\(A_1A_2…A_n\)</span>,将A变为 <span class="math inline">\(A_nA_1A_2A_3…A_{n-1}\)</span> )</li>
<li>3：可以任意挑选一个 <span class="math inline">\(i\)</span> ，若 <span class="math inline">\(B_i = 1\)</span> ，则 <span class="math inline">\(A_i \wedge{} =1\)</span>。</li>
</ul>
<p>每种操作的操作次数不限，问最少操作几次可以使 <span class="math inline">\(A=B\)</span>，如果无法使 <span class="math inline">\(A=B\)</span>，则输出 <span class="math inline">\(-1\)</span>。</p>
<p><span class="math inline">\(n \le 2000\)</span></p>
<p>样例输入：</p>
<pre>
1010 
1100

</pre>
样例输出：
<pre>
3

</pre>
<hr>
<p>给你 <span class="math inline">\(n\)</span> 个物品，每个物品有 <span class="math inline">\(3\)</span> 种属性(<span class="math inline">\(a_i,b_i,c_i\)</span>)，现在你需要从中挑选 <span class="math inline">\(k\)</span> 个物品，分别是 <span class="math inline">\(t_1,t_2,t_3…t_k\)</span>. 这 <span class="math inline">\(k\)</span> 个物品需要满足以下条件：</p>
<ul>
<li>1：<span class="math inline">\(a_{t_1} \wedge{} a_{t_2} \wedge{} a_{t_3} \wedge{} a_{t_4}… \wedge{} a_{t_k}=0\)</span>。</li>
<li>2：对于任意一个 <span class="math inline">\(b_i\)</span>，都至少存在一个 <span class="math inline">\(j\)</span> (<span class="math inline">\(j \le k\)</span>)，使得 <span class="math inline">\(b_{t_j}=b_i\)</span>。</li>
<li>3：<span class="math inline">\(c_{t_1},c_{t_2},c_{t_3}…c_{t_k}\)</span>必须互不相同。</li>
</ul>
<p>时间限制：2s</p>
<p>数据范围：<span class="math inline">\(1 \le n \le 32\)</span>,<span class="math inline">\(1 \le b_i,c_i \le n\)</span>,<span class="math inline">\(1 \le a_i \le 100000\)</span>。</p>
<p>样例输入：</p>
<pre>
5
1 2 1
1 1 2
1 2 2
2 1 1
3 2 2

</pre>
<p>样例输出：</p>
<pre>
2

</pre>
<hr>
<p>给你一棵 <span class="math inline">\(n\)</span> 个点的树和 <span class="math inline">\(m\)</span> 条非树边，每条非树边有一个权值 <span class="math inline">\(x_i\)</span>。</p>
<p>你可以从 <span class="math inline">\(m\)</span> 条边中挑选若干条加到树中，但必须保证每个点最多只能属于一个简单环，你能得到的收益是这些边的权值和。</p>
<p>求收益的最大值。</p>
<p><span class="math inline">\(n \le 2*10^5,m \le 2*10^5\)</span>。</p>
<p>样例输入：</p>
<pre>
7 3
1 1 2 2 3 3
4 5 1
6 7 1
2 3 1

</pre>
<p>样例输出：</p>
<pre>
2

</pre>
<hr>
<p>给定一棵 <span class="math inline">\(n\)</span> 个节点的有根树，在输入数据通过给出每个节点的父亲来表示这棵树。若某个节点的父亲为 <span class="math inline">\(0\)</span> ，那么该节点即为根。现在对于每个点 <span class="math inline">\(i\)</span> ，询问它的每个祖先的子树中深度不超过 <span class="math inline">\(i\)</span> 的点的数量的总和(不包括i自己)。</p>
<p>时间限制：2s</p>
<p><span class="math inline">\(n \le 5*10^5\)</span></p>
样例输入：
<pre>
4
0 1 2 1

</pre>
<p>样例输出：</p>
<pre>
0 2 4 2

</pre>
<hr>
<p>给你一棵 <span class="math inline">\(n\)</span> 个点的有根树，每个点有一个点权 <span class="math inline">\(a_i\)</span>，你需要在树上挑选尽可能多的点，但必须满足以下条件：</p>
<p>如果你选取了 <span class="math inline">\(x,y\)</span>，且 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(y\)</span> 的祖先，则 <span class="math inline">\(a_x &gt; a_y\)</span>。</p>
<p>求最多能取多少个点。</p>
<p>数据范围：<span class="math inline">\(n \le 100000\)</span>。</p>
<hr>
<p><span class="math inline">\(t\)</span> 次询问，每次给你 <span class="math inline">\(n\)</span> 个数 <span class="math inline">\(x_1,x_2…x_n\)</span>，把它们按不同的顺序排列，一共可以得到 <span class="math inline">\(n!\)</span> 个新的数，问这 <span class="math inline">\(n!\)</span> 个数中，有多少数能被 <span class="math inline">\(11\)</span> 整除，答案 <span class="math inline">\(\% 998244353\)</span>。</p>
<p><span class="math inline">\(n \le 2000，1 \le x_i \le 10^9\)</span>。</p>
<p>样例输入：</p>
<pre>
4
2
1 1
3
1 31 12
3
12345 67 84
9
1 2 3 4 5 6 7 8 9

</pre>
<p>样例输出：</p>
<pre>
2
2
2
31680

</pre>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>